---
title: 并发编程
date: 2016-08-22 12:23:40
tags:
  - Cpp
  - 并发编程
categories:
  - 笔记
---

在学习操作系统的进程和线程部分理解进程和线程的概念, 进程和线程具有并发性, 希望可以在代码层面学习并实践一下, 参考资料是forhappy的 [Cplusplus-Concurrency-In-Practice](https://github.com/forhappy/Cplusplus-Concurrency-In-Practice/blob/master/README.md)

<!--more-->
### 环境

1. 下载 [x86_64-w64-mingw32-gcc-4.8-stdthread-win64_rubenvb.7z](http://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/rubenvb/gcc-4.8-experimental-stdthread/)编译器并在`Codeblocks`中配置

2. 具体配置见 [stackoverflow : C++11, GCC 4.8.1,Code::Blocks, threading, what a head ache](http://stackoverflow.com/questions/18951454/c11-gcc-4-8-1-codeblocks-threading-what-a-head-ache)

测试代码:

```
#include <stdio.h>
#include <stdlib.h>

#include <chrono>    // std::chrono::seconds
#include <iostream>  // std::cout
#include <thread>    // std::thread, std::this_thread::sleep_for

void thread_task(int n) {
    std::this_thread::sleep_for(std::chrono::seconds(n));
    std::cout << "hello thread "
        << std::this_thread::get_id()
        << " paused " << n << " seconds" << std::endl;
}

int main(int argc, const char *argv[])
{
    std::thread threads[5];
    std::cout << "Spawning 5 threads...\n";
    for (int i = 0; i < 5; i++) {
        threads[i] = std::thread(thread_task, i + 1);
    }
    std::cout << "Done spawning threads! Now wait for them to join\n";
    for (auto& t: threads) {
        t.join();
    }
    std::cout << "All threads joined.\n";

    return EXIT_SUCCESS;
}
```

### **并发与并行**

- 并发是一个处理器同时处理多个任务，而并行多个处理器或者是多核的处理器同时处理多个不同的任务
- 并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生