---
title: 面向对象设计
toc: true
tags:
  - 面向对象
  - UML
  - 设计模式
categories:
  - 编程之美
date: 2016-10-25 18:07:38
---

在之前并没有系统的学习过面向对象的程序设计, 最近在读面向对象设计的书, 一直在听说设计模式这个词, 听起来就很炫酷, 准备每天学习一种设计模式, 采用Java语言, 参考书为`设计模式之禅(第二版)` , 参考网站为 [图说设计模式](http://design-patterns.readthedocs.io/zh_CN/latest/index.html)

<!--more-->

首先面向对象的语言的核心就是`可扩展性`, 那么设计原则的根本目的就是`保证程序可拓展性`, 设计模式就是`提高程序可拓展性`, 设计原则和设计模式是互补的关系, 设计原则主要指导`类的定义`, 而设计模式主要指导`类的行为`


对于"面向对象"这个概念初学的时候总是跟语言联系在一起, 这种想法是不对的, 面向对象更应该理解为一种编程思维, 也就是说C语言依然可以写成面向对象的, Java也可以写成面向过程的, 是否面向对象这取决于你的编码思维, 世间的万物皆为对象, 即万物都有属性和动作, 接下来我们看看怎样在程序中抽象对象

## **面向对象**

### 类与对象
对于刚刚接触面向对象语言的新手来说，理解面向对象的概念就是一个门槛，感觉模模糊糊地似懂非懂，其实有时候读偏哲学的书的时候也会给你同样的感觉。世间万物都可以用两个维度来描述，一个是它本身所具有的属性，另一个是本身可以发生的动作，二者结合起来就是一个对象。我们把生物世界分成不同的物种，是因为寻找到了相同物种之间的共同之处，寻找的过程就是一个抽象的过程，举个例子，把不同品种的猫都叫做猫，猫就是一个类，而特定的某一品种的猫就是一个对象，因为他们有共同的属性可以发出相同的动作，而这个品种具体的一只活生生的猫就是这个对象（猫）的实例。对象一定是抽象出来的，而这种设计哲学更加的抽象出了现实世界。
- 类是一个抽象的概念, 而对象是通过`new`操作产生的抽象类的一个实例, 可以把对象理解为一个具象的概念.下面比较二者不同:

|  名称 |  概念  | 存放位置 |
|------|-----------|---------|
|  类  |  抽象  |  堆栈(对象引用)  |
|  对象  |  具象  |  堆内存(对象本身)  |

- 为了提高效率, Java的基本类型`int`,`char`,`boolen`等是存放在堆栈中的, 也可以通过包装器类`new`到堆内存中.

### **面向对象类**

那么我们怎样抽象一个类, 怎样区分属性和方法呢?

对于一种事物, **名词**是属性, **动词**是方法

- 设计属性原则 : **属性不可再细分**
- 设计方法原则 : **一个方法只做一件事情**

> 所有面向对象的特性来源于两点:`效率`和`设计`

### **接口(interface)**

- **功能** : 不知道一个对象所属的具体类, 只知道这些对象都具备某种功能, 它是一组相关的交互功能点定义的集合
- 通过实现(implements)接口定义具体的功能

### **抽象类(abstract)**

- **功能** :　只能用于继承，不能被实例化为具体的类，比如在Java中不能`new`一个抽象类的实例，但是可以`extend`
- 如果普通类是对现实对象的高层次抽象, 那么抽象类就是对普通类的高层次抽象

与`接口`不同的是, 抽象类本质上还是类, 是属性和方法的具有相似性的普通类的一种高层抽象; 但是接口只是定义了方法声明上的相似性, 而没有方法定义上的相似性
### **封装** 

- 把数据和方法包装进类中 , 以及把具体实现的过程隐藏起来 , 成为一个同时带有特征和行为的数据类型
- 使用封装保护了数据的隐私, 在`封装`特性中, 对外提供接口，屏蔽数据，对内开放数据。
  
### **继承(extends)** 

- 继承就是继承了父类的属性和方法, 提高了代码的复用率, 同时对于子类的改写提高了可扩展性, 也正是必须继承父类的属性和方法增强了耦合性在改写父类时要考虑子类
- 抽象和继承是前后衔接的关系, 先有抽象, 通过抽象得出类, 后通过继承来表达抽象结果

`重载Overlord`: `函数重载`在设计上可以达到简化编程的目的
         
  - 重载规则:
   1. `函数名`相同
   2. `参数个数`不同或者`参数类型`不同或者`参数顺序`不同, 至少满足其一均可构成重载
   3. `返回值类型`不同并不可以构成重载, 因为有时候我们并不关心函数的返回值, 实现功能就可以
  - `重写Override`:在继承了父类的方法后, 要重写一个函数, 函数名和参数必须与原函数一致

### **多态**

- 在面向对象领域中, 多态的真正含义是 : 使用指向父类的指针或者引用, 能够调用子类的对象
- 多态屏蔽子类对象的差异, 可以使得调用者写出通用性的代码, 而无需对每个子类来写不同的代码
- 当增加新的子类时候, 调用者无需变动就能适应新的子类

### **技术流程**

在了解了面向对象的基本理论后, 我们来看一看项目的过程:

需求模型 $\to$ 领域模型 $\to$ 设计模型 $\to$ 实现模型

## **UML**

`UML`是统一建模语言(Unified Modeling Language)的缩写, UML是使得表达程序设计更加形象生动

**实例**

![](/img/面向对象设计/uml_class_struct.jpg )

- `车`是一个`抽象类`；它有两个`继承类`：小汽车和自行车；它们之间的关系为`实现关系`，使用带空心箭头的虚线表示；
- 小汽车为与SUV之间也是继承关系，它们之间的关系为`泛化关系`，使用带空心箭头的实线表示；
- 小汽车与发动机之间是`组合关系`，使用带实心箭头的实线表示；
- 学生与班级之间是`聚合关系`，使用带空心箭头的实线表示；
- 学生与身份证之间为`关联关系`，使用一根实线表示；
- 学生上学需要用到自行车，与自行车是一种`依赖关系`，使用带箭头的虚线表示；

### **泛化关系**

> (generalization) : 子类继承某个非抽象类, 本质上就是类的继承

 ![](/img/面向对象设计/uml_generalization.jpg)
 - **UML表示** : 带空心三角形的连接实线
 
### **实现关系**

> (realize) : 将抽象类实现为具体的某个子类, 是继承的一种特殊实现

 ![](/img/面向对象设计/uml_realize.jpg)
 - **UML表示** : 带空心三角形的连接虚线
 
### **关联关系**

> (association) : 最弱的一种联系, 通常用排除法确定

 ![](/img/面向对象设计/uml_association.jpg)
 
### **依赖关系**

> (dependency) : 比`关联`更强的一种关系, 一个类依赖另一个类, 就意味着一旦被依赖的类改变, 则依赖类也要改变, 依赖的形式是`方法调用`/`数据访问`/`对象传递`

 ![](/img/面向对象设计/uml_dependency.jpg)
 
**依赖关系可以形象的描述为`没有你我寸步难行`, 聚合和组合则是`没有你我将不复存在`, 描述的是一种`整体和部分`的关系**

### **聚合关系**

> (aggregation) : 描述`has a`的关系, 就是某个类包含了另外一个类, 但并不负责被包含类的维护(在Java中指的是创建对象实例), 且两个类的生命周期不一样, `整体`消失后`部分`还能继续存在

 ![](/img/面向对象设计/uml_aggregation.jpg)
 
### **组合关系**

> (composition) : 描述`owns a`的关系, 就是某个类包含了另外一个类, 但并负责被包含类的维护, 且两个类的生命周期一样, `整体`消失后`部分`不能继续存在, 组合是一种强耦合关系, 具有相同的生命周期

 ![](/img/面向对象设计/uml_composition.jpg)
 

## **设计原则**

### **内聚**

`内聚`指一个模块内部元素彼此结合的紧密程度, 可以判断一个模块(`函数/类/接口/包/子系统`)的设计是否合理, 是指一个模块内部元素彼此结合的紧密程度, 那么什么是`元素`呢?

- `函数`的元素是`代码`
- `类/接口`的元素是`属性`和`方法`
- `包`的元素是`类/接口/全局数据`等
- `模块`的元素是`包/命名空间`等

在判断一个模块(`函数/类/接口/包/子系统`)的内聚性的高低, 最重要的是关注元素是否是同一职责, 所谓的`高内聚`也就是说尽量一个类里的函数都只依赖于本类中的其他函数

**内聚分类**

- **逻辑内聚** : 从逻辑上划分内聚的高低, 但是这种逻辑并不可控, 比如IO设备(输入设备/输出设备)
- **时间内聚** : 在时间的顺序上具有相似性, 元素间的顺序是不固定的
- **过程内聚** : 元素必须按照固定的处理顺序进行, 不能随意调整
- **信息内聚** : 所有元素都操作相同的数据
- **顺序内聚** : 某些元素的输出是另外元素的输入
- **功能内聚** : 所有元素都是为了同一个任务, 缺一不可

### **耦合**

`耦合`是程序模块之间的依赖程度, 而内聚关注的是模块内部元素间的结合程度, 这里的`模块`可大可小, 可以指`函数/类/接口/包/子系统`等

所谓`依赖`指的是某个模块用到了另外一个模块的一些元素, 元素可大可小

**耦合分类**

- **消息耦合** : `消息`随模块的不同而不同, 比如子系统的消息是`系统交互接口`, 类的消息是`类的方法`, 消息耦合是耦合度很低的, 因为调用方仅仅依赖被调用方的`消息`, 既不需要传参数也不需要了解被调用方的内部逻辑, 更不需要控制被调用方的内部逻辑, 只是单纯的调用关系

- **数据耦合** :  两个模块间通过`参数传递`(而不是通过全局数据/配置文件/共享内存等其他方式)`基本数据类型`(int/double/String等类型)

- **数据结构耦合** : 两个模块间通过传递`数据结构`的方式传递数据, 在传递的数据结构中的成员数据并不需要每一个都用到, 可以只用到一部分

- **控制耦合** : 一个模块通过某种方式来控制另一个模块的`行为`, 比如通过传入一个控制参数来控制函数的处理流程和输出, `工厂模式`

- **外部耦合** : 两个模块之间没有直接的交互, 而是依赖相同的外部数据格式/通信协议/设备接口等完成分工合作

- **全局耦合** : 两个模块共享相同的全局数据

- **内容耦合** : 一个模块依赖另一个模块的数据成员(public属性), 也就是说一个模块的方法操作了另一个模块的数据成员, 完全破坏了模块的封装性

> 为什么要`高内聚低耦合`?

这条原则主要是`降低模块的复杂性, 增加模块的稳定性`, 反向思维来理解这个问题

- 低内聚的模块意味着在对类的认识上十分困难, 因为低内聚意味着类中的方法相似性很低, 无论是在逻辑或者功能上的相似性, 在阅读代码时候很难理解, 同时一旦类发生变化, 设计/编码/测试/编译的工作量就增大很多;

- 高耦合意味着模块间的依赖很多, 这样依赖的其他模块任何一个发生变化, 该模块都必须做出修改, 同样使得后续设计/编码/测试/编译的工作量增大很多

`牵一发而动全身`意味着模块的稳定性很差, 这样的不稳定性导致产品和成本带来很大的风险

**注意**, 并不是内聚越高越好, 耦合越低越好, 因为高内聚和低耦合是相互矛盾的

> 为什么高内聚和低耦合是相互矛盾的?

- 对于内聚来说, 最高的内聚是一个模块只完成一项功能, 比如一个类只有一个方法, 但是会导致类的数量急剧增加, 导致模块间的耦合特别多
- 对于耦合来说, 最低的耦合是一个模块完成所有的功能, 比如将所有方法全部写入一个类, 导致内聚非常低

所以, **真正好的设计是`高内聚和低耦合间的平衡`**
### **单一职责**
 
> 应该有且仅有一个原因引起类的变更, 就是说一个接口或者类只有一个职责, 对于面向对象来说, 一个类负责多个相关功能

**好处**

- 类的复杂性降低使得可读性和可维护性提高
- 变更引起的风险降低, 只对其实现类有影响, 对其它接口没有影响

但是`职责的划分`没有一个量化标准, 实际上我们很难做到单一职责, 单一职责导致实现类剧增, 反而增加了复杂性从而难以维护, 单一职责只适合那些基础类, 不适合基于基础类的复杂聚合类

### **里氏替换**

> 只要父类出现的地方子类就可以出现, 并且将子类替换为父类也不会出现任何错误和异常, 使用者不需要知道是子类还是父类, 但是反过来有子类出现的地方父类未必能够替代子类

- 该原则对继承定义了规范, 这样子类必须完全实现父类的方法, 父类是一个抽象类
- 在使用子类的时候务必要使用抽象父类拥有的抽象方法, 否则就违背了里氏替换原则
- 在子类不能完整的实现父子的业务, 或者父类的某些方法在子类中已经发生了畸变, 那么不使用继承, 而采用依赖/聚合/组合等关系
- `向下转型`是不安全的, 在里氏替换原则的角度看就是有子类出现的地方替换为父类未必可以

_向上转型： `Person p = new Man() ;` //向上转型不需要强制类型转化_
_向下转型： `Man man = (Man)new Person() ;` //必须强制类型转化_

**如何判断是否符合里氏替换原则?**

对于调用者来说, 和父类的交互无非两点, `调用父类中的方法`和`得到父类方法的输出`, 基于这两点如要符合里氏替换原则, 那么子类必须满足以下三点 :

- 子类必须实现或者继承父类所有的public方法
- 子类每个方法的输入参数必须和父类一样
- 子类每个方法的输出必须不比父类少

**参数放大问题**

- 在子类中, 重写或实现父类的方法时, 输入参数可以被放大, 就是子类中输入参数的范围大于父类参数的类型范围, 子类可以代替父类将参数传递到父类中定义的方法, 因为通过继承之后子类中定义的方法永远不会执行, 始终保证父类的方法被调用, 这样子类替换掉父类就不会出现问题, 所以`子类中方法的前置条件必须与超类中被重写的方法的前置条件相同或者更宽` , 方法中输入的参数就是`前置条件`

### **依赖倒置**

> 高层模块不应该依赖低层模块, 两者都依赖其接口或者抽象类, 实现类之间不发生直接的依赖关系, 通过接口或者抽象类产生依赖关系
> 接口或者抽象类不应该依赖实现类, 实现类应该依赖接口或者抽象类

依赖倒置原则的本质是通过抽象(抽象类或者接口)使得各个类或者模块实现彼此的独立, 实现模块间的松耦合, 遵照一下规则:

1. 每个类尽量具有接口或者抽象类

2. 变量的声明类型尽量是接口或者抽象类

3. 任何类都不应该从具体类派生

4. 尽量不要重写基类的方法

5. 结合里氏替换原则

`接口`负责定义public属性和方法, 并声明与其他对象的依赖关系; 
`抽象类`负责公共构造部分的实现;
`实现类`负责准确的实现业务逻辑;

### **接口隔离**

> 接口尽量细化, 同时接口本身的方法尽量少, 而不是建立一个庞大的接口, 允许所及的客户端进行访问

1. 接口尽量要小, 但是必须满足单一职责原则
2. 接口要高内聚

### **最少知识**

> 一个对象应该对其他对象有最少的了解

1. 如果一个方法放在本类中, 既不影响类间关系, 也对本类不产生负面影响, 那就放置在本类中

### **开闭原则**

> 软件实体(模块/抽象/类/方法)应该通过扩展来实现变化, 而不是通过修改已有的代码来实现变化, 但并不意味着不做任何修改, 底层模块的变更必然要有高层模块进行耦合

- 只变化一个逻辑, 不涉及其他模块的变化, 可以通过修改原有的方法来进行

## **设计模式**

基于面向对象的特性寻找原型设计的通用方法, 使得程序的扩展性和效率都得以提高 

### **单例模式**

> 确保一个类只有一个实例

- 如何禁止一个非抽象类在类的外部使用`new`关键字实例化, 由于使用`new`关键字进行实例化的时候会调用相应的`构造函数`, 将构造函数设为`private`就可以了

```java
public class Emperor {
	private static final Emperor emperor =new Emperor();  //初始化一个皇帝	
	private Emperor(){
		//世俗和道德约束你，目的就是不希望产生第二个皇帝
	}
	public static Emperor getInstance(){
		return emperor;
	}
}
```

### **策略模式**

> 定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为`政策模式(Policy)`

**使用场景**

- 实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。

**硬编码**
  在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为`硬编码`，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。
  

  为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类或接口来做算法的定义，而具体每种算法则对应于一个具体策略类。

![](/img/面向对象设计/Strategy.jpg)

- Context: 环境类, 即策略的选择功能实现
- Strategy: 抽象策略类, 即策略的接口
- ConcreteStrategy: 具体策略类, 即策略接口的具体实现